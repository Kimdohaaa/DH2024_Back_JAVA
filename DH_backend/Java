[컴파일]
컴퓨터가 이해할 수 있는 언어로 번역하는 행위

[컴파일러]
컴퓨터가 이해할 수 있는 언어로 번역하는 프로그램

[JAVA의 장점]
1. (JVM : 자바 가상 머신) 운영체제(플랫폼)로 부터 독립적이다.
    -> 코드(.class)를 한번 작성하면 여러 운영체제에서 실행 가능
2. 객체지향 언어이다. 
    -> 유지보수가 쉬움 / 확장성 우수
3. 안정적이다. 
    -> 가비지 컬렉터(GC)가 메모리를 자동(동적)으로 관리
4. 오픈소스(미리 만들어진 소스)
    -> JDK / SPRING /JSP 등 다양한 오픈소스 제공

[JAVA의 사용처]
1. 웹
2. 앱
3. 게임



[진수]
2진수 / 8진수 / 10진수 / 16진수

[단위]
비트 -> 바이트 -> 킬로바이트 -> 메가바이트 -> 기가바이트 -> 테라바이트
- 1비트 : 명령어의 최소단위
- 1바이트(8비트) : 운영체제 용량의 최소 단위
- 1킬로바이트(1024바이트)

[아스키코드]
이용한 영문자 / 숫자 / 특수문자를 7비트로 정의해놓은 규칙 -> 한글지원 X (유니코드는 한글 지원)
=> 2(비트)의 7승으로 128 표현가능 -> 가장 앞 비트는 부호비트

[컴퓨터의 부호 있는 수 표현]
1. 부호화 - 크기
2. 1의 보수
3. 2의 보수


[변수]
- 변하는 수
- 값을 넣을 수 있는 공간
1. 변수의 형태
    자료형 변수명 = 리터럴;
2. 변수의 선언
    - 선언 : 자료형 변수명;
    - 초기화 : 자료형 변수명 = 리터럴;
3. 변수 선언 제약사항
    - 숫자로 시작 X
    - 특수 문자는  _(언더바) / $(달러) 만 사용 가능
    - 키워드 사용불가

[기본 자료형] -> 메모리를 효율적으로 할당하기 위해 사용할 값에 맞는 자료형 사용
1. 논리형 자료형
    - boolean
        - 1 byte
        - true / false 만 표현 가능
2. 문자형 자료형
    - char -> 한글자
        - 1 byte
        - 유니코드
        - ''(작은 따옴표) 사용
3. 정수형 자료형
    - byte
        - 1 byte
        - +-128 까지 표현 가능
    - short
        - 2 byte
        - +-3만 까지 표현가능
    - int 
        - 4 byte
        - +- 21억 까지 표현가능
        ★ 리터럴 정수(= 정수의 기본타입 ) -> 키보드로 입력하는 모든 값은 int형이다.
    - long
        - 8 byte
        - +- 21억 이상 까지 표현 가능
        ★ 정수의 기본타입은 int 형이기 때문에 long자료형 
           사용 시 값 뒤에 L을 붙여 사용
4. 실수(=부동소수점)형 자료형
    - float
        - 4 byte
        - 소수점 8자리 까지 표현 가능
        ★ 실수의 기본타입은 double 형이기 때문에 float자료형 
           사용 시 값 뒤에 F을 붙여 사용
    - double
        - 8 byte
        - 소수점 17자리 까지 표현 가능
        ★ 리터럴 실수(= 실수의 기본 타입)


[참조 / 클래스 자료형]
1. String
2. Scanner
3. 클래스 
=> 기본 자료형 8개 이외의 자료형
	
-> String Scanner 은 참조타입으로 대문자로 시작됨
[부동소수점]
1. float 
    - 부호비트 : 1비트 
    - 지수부 : 8비트 사용 
    - 가수부 : 23비트 사용
2. double
    - 부호비트 : 1비트 
    - 지수부 : 11비트 사용 
    - 가수부 : 52비트 사용
ex . 1000000
        -> 지수부(숫자의 크기) : 10의 6승
        -> 가수부(숫자의 유효 자릿수) : 1
        => 1.0 * 10의 6승

-> 0과 1 사이의 실수는 끝없는 무한대 표현이 가능 
    => 컴퓨터의 한계(표현 한계가 넘어가 무한대에 빠지기 때문)
-> 한계 발생으로 인해 실제 연산이 중요한 부분의 업무에서는 실수타입 사용 x 
    => 라이브러리 또는 문자열 처리를 통해 실수 계산


[Java 파일 형식]
1. .java : 자바코드를 작성할 수 있는 확장자 명 => 자바코드
2. .class : 자바가 .java 파일을 컴파일하여 만들어진 파일 => 기계어
3. main함수 : 스레드가 내장된 함수 => main함수 밖에 코드 작성 시 번역은 되지만 실행은 불가
		★ 스레드 : 번역된 코드를 읽는 실행 흐름
=> Java는 위 3가지가 반드시 포함되어야 실행 가능
		
- 과정 : 개발자가 .java파일에서 .class 문법작성 ---> 컴파일 ---> class파일 생성
- .class파일위치 :  workspace -> 프로젝트 -> bin 폴더 > .class 파일

-> 하나의 자바파일에 여러 개의 클래스 선언가능 => 페이지 내 .class파일이 따로 만들어짐
-> 자바는 HTML / JS 등과 달리 자체 컴파일이 가능하다.

[상수]
- final 키워드 사용
- 관례적으로 모든 단어를 대문자로 작성

[리터럴]
개발자가 키보드로 입력한 숫자 / 문자 / 논리 를 일컫는 말
-> Java의 경우 리터럴 값이 상수풀(메모리의 공간)이라는 공간에 상수로 저장되어있음

[형변환]
- 기본 원칙
	1. 메모리 크기 ↓ => 메모리 크기 ↑
	2. 정밀도 ↓ => 정밀도 ↑
	(정수)
	byte(1바이트) -> short / char(2바이트) -> int(4바이트) -> long(8바이트)
	=>	(실수는 정수보다 표현범위가 넓고 정밀하기 때문에 long(8바이트)에서 float(4바이트)로 형변환 가능)
	(실수)
	float(4바이트) -> double(8바이트)

1. 묵시적형변환(=자동형변환)
	- byte + byte = int
	- byte + short => int
	- int + int => int
	- int + long => long
	- int + float => float
	- float + double => double
	★ 예외 . byte / short의 연산은 무조건 int형이 됨
	
2. 명시적형변환(=강제형변환(캐스팅))
	- 메모리 크기 ↑ -> 메모리 크기 ↓
	- 데이터 손실이 생길 수 있음
	- 연산 중 강제형변환도 가능
	- 형식 : (변환할 자료형)변수명

=> 형변환을 통해 Java의 특징 중 하나인 다형성(객체가 여러 개의 형식 / 자료형을 가지는 성질) 표현가능

[입출력]
1. 입력함수
	- Scanner
		1) 입력 객체 생성
			- 형식 : new 클래스명();
		2) .nextXXX() : 입력 객체로 부터 console 에서 키보드로 입력받은 값을 가져오는 함수
	
			- 문자열 입력 
				1) 변수명.next(); : 엔터 기준으로 하나의 (next) 입력을 마침 처리 / 띄어쓰기 불가능
				2) 변수명.nextLine(); : .next()와 같으나 띄어쓰기 가능
					★ 주의점 . 다른 nextXXX()코드와 같이 사용 시 앞 전 .nextXXX의 엔터를 포함하므로 하나로 인식함 
					★ 해결법 . 의미없는 scan.nextLine()을 사용하므로 실 사용할 nextLine()과 구분함.
	
			- 정수형 입력
				1)변수명.nextByte();
				1)변수명.nextShort();
				1)변수명.nextInt();
				1)변수명.nextLong();
				★ char 형은 사용 불가
	
			- 실수형 입력
				1)변수명.nextFloat();
				1)변수명.nextDouble();
	
			- 논리형(boolean) 입력
				1)변수명.nextBoolean();
				★ boolean형이기 때문에 입력 값이 true / false 만 가능				
	
	=> 입력 객체 1개로 각 자료형 별로 사용 가능함
	=> 각 자료형의 허용범위를 벗어날 시 오류가 발생함

2. 출력함수
	- System.out.printIn()
		-> System : 시스템 관련 기능을 제공하는 클래스(설계도)
		-> out : 출력 관련 객체 반환
		-> . : 접근 연산자
		1. println() : 인수 값을 console에 출력 후 줄바꿈 처리를 하는 함수
		2. print() : 인수값을 console에 줄바꿈하지 않고 출력하는 함수
		3. printf() : 인수 값에 형식문자를 이용하여 수식을 출력하는 함수
			★ 형식 : printf("형식문자", 형식대입값);
			★ 형식문자 : printf() 함수에서 사용되는 의미가 담긴 문자
				1. %s : 문자열
				2. %c : 문자
				3. %d : 정수
				4. %f : 실수
				5. %자릿수d : 자릿수만큼 자릿수 차지 (만일 비어있으면 공백 처리) / 오른쪽 정렬
				6. %-자릿수d : 자릿수만큼 자릿수 차지 (만일 비어있으면 공백 처리) / 왼쪽 정렬
				7. %0자릿수d : 자릿수만큼 자릿수 차지 (만일 비어있으면 '0'처리) / 오른쪽 정렬
				8. %전체 자릿수.표현할 소수점 자릿수f : 자릿수만큼 자릿수 차지 / 소수점은 소수점자릿수 까지 차지

3. .equals 함수 : 참조 비교
	-> null 의 경우 힙메모리가 아닌 리터럴이기 때문에 X
[연산자]
1. 산술 연산자 : +(가) / -(감) / *(승) / /(목ㅆ) / %(나머지)
2. 연결 연산자 : + 
3. 비교 연산자 : >(초과) / <(미만) / >=(이상) / <=(이하) / ==(같다.) / !=(같지않다.) 
                / ==(값,타입이 같다.) / != (값, 타입이 같지 않다.)
                => 반환값 : 논리값(True / False)
4. 관계 연산자 : &&(논리곱) / ||(논리합) / !(부정)
                => 반환값 : 논리값(True / False)
5. 증감 연산자 : ++변수명; / --변수명; -> 전위증감연산자 (출력 전 값 증가(변수 값 == 수식 값))
                변수명++; / 변수명--; -> 후위증감연산자 (출력 후 값 증가(변수 값 =/= 수식 값))
6. 대입 연산자 : =
7. 복합 대입 연산자 : += / -= / *= / /= / %= 
8. 삼항 연산자(피연산자 = 3개) 
    - 조건문 ? true일 때 반환 값 : false일 때 반환 값;
    - 조건문1 ? true일 때 반환 값 : 조건문2 true일 때 반환 값 : false일 때 반환 값;
                -> 삼항 중첩 연산자
9. 비트 연산자
10. new 연산자 : 객체 생성 연산자
11. . : 접근연산자
등등 


---------------------------------------------------------------------------------------------------

[객체]
- 주체의 의사나 행위가 미치는 대상 => 본인(주체)을 제외한 모든 대상
ex . 사람 / 자동차 / 건물 / 주문 / 생산 / 관리 등 현실세계의 유무형의 모든 것
- 객체 생성 시 할당되는 메모리 공간 : 힙 메모리 

[객체지향 프로그래밍]
- 어떤 대상(객체)를 가지고 프로그래밍하는 것

[인스턴스]
- 정의 : 지역 변수가 힙에 할당된 메모리를 가리키는 것 -> 객체가 실질적으로 사용 가능해짐
- 참조변수 : 인스턴스를 가리키는 클래스형 변수
	-> 참조변수를 사용하기 위해 .(접근연산자) 사용

		----( 객체 )----
  	   |               |
           ( 인스턴스 )  
	   |_______________|

----------------------------------------------------------------------------------------------------

[클래스]
- 정의 : 객체의 속성과 기능을 코드로 구현한 것
	=> 멤버변수 : 대상의 본질적인 성질 / 특징 / 특성
	=> 멤버함수(=메소드) : 함수(대상의 작동 / 행위 / 이벤트)
	=> 생성자
	=> 가시성 지시어 : public / private / protected
- 자바에서 클래스 생성 시 main 함수 체크를 풀고 생성
- 형식 : class 클래스명 { 멤버변수; 메소드; };
ex . 학생
		- 속성(멤버변수) : 학번 / 이름 / 학년 / 사는 곳 등
		- 기능(메소드) : 공부하기 / 잠자기 / 버스타기 등
		- public class Student{
			int studentId;
			String studentName;
			int grade;
			String address;
		  }
	자동차
		- 멤버변수 : 제조사 / 차량번호 / 색상 / 현재속도 / 엔진상태
		- public class Car{
			String 제조사;
			String 차량번호;
			int 현재속도;
		  }
	주문 
		- 멤버변수 : 수량 / 주문번호 / 제품명 / 주문날짜
		- public class Order{
			int 수량;
			String 주문번호;
			String 제품명;
		  }
		
- 개발자 지정 자료형 역할
- 종류
	1) 객체 설계도 클래스
	2) main 함수를 갖는 실행 클래스
- 멤버변수의 기본값 -> 초기화 생략 시 자동으로 기본값이 대입됨 (멤버변수만 가능)
	- 정수 : 0
	- 실수 : 0.0
	- 논리 : false
	- 클래스타입 : null


[메서드(=멤버함수)]
- 정의  : 하나의 기능을 수행하는 일련의 코드
- 사용목적
	1) 반복되는 기능 중복 사용
	2) 여러 명령어를 묶음으로 저장
	3) 가독성
	4) 
- 함수명 : 관례적으로 카멜표기법 사용
- 매개변수 : 입력 받는 값	-> 없는 경우 O
	=> 함수 호출 / 사용 시 인수값을 중매(=연결)하여 대입받는 변수
	★ 주의점 . 인수값의 자료형 == 매개변수 자료형 
- 반환값 : 함수를 수행한 결과값  -> 없는 경우 O ★ 반환값이 없는 경우 함수의 반환자료형으로 void 지정
	=> return : 반환값 / 함수종료
	★ 주의점 . 함수의 반환자료형 == 반환값의 자료형  
- 함수 선언
	- 형식
		반환자료형 함수명 (매개변수자료형 매개변수){
			실행할 코드;
			return 반환값;
		}
- 함수호출
	1) 내부함수 : 호출하고자 하는 함수가 같은 클래스에서 선언된 경우 
		형식 : 함수명();
		i- static 키워드가 선언된 함수
		ii- static 키워드가 선언되지 않은 함수
	2) 외부함수 : 호출하고자 하는 함수가 다른 클래스에서 선언된 경우 -> 객체 필요
		형식
			1- 클래스 변수명 = new 생성자(); // 외부함수의 메소드에 접근하기 위한 객체 생성
			2- 변수명.메소드명();		
			
- 함수 호출 시 : 메모리 공간 할당 -> 함수에 할당되는 메모리 공간 : 스택(LIFO)구조
- 함수 종료 시 : 메모리 공간 반환 -> 메모리 공간을 반환하는 순서 : 마지막으로 호출된 함수에 할당된 메모리 공간 -> 처음으로 호출된 함수에 할당된 메모리 공간  


[생성자]
- 정의 : 클래스를 처음 만들 때 멤버 변수 / 상수를 초기화하는 것
- 목적 : 멤버변수에 대한 값들을 매개변수로 받아서 인스턴스가 생성될 때 멤버변수의 값을 초기화 하는 역할 / 유효성 검사
- 사용처 : 객체를 생성자 객체 내 멤버변수에 처음값을 대입하고자 할 때 생성자 선언 -> 객체를 만들 때 객체 내 멤버변수 값들 중 초기에 빠른 대입이 필요한 것이 있는지 판단
		- 객체 생성 시 상황에 따라 초기값이 다르면 다양하게 생성자를 상황에 맞추어 만든다.
		ex . 게시물 등록 시 필요한 생성자 / 게시물 수정 시 필요한 생성자 / 게시물 삭제 시 필요한 생성자 
		 
- 선언 규칙 
	1) 생성자명 == 클래스명 
	2) 함수와 동일하게 매개변수는 존재할 수 있지만 반환값은 존재하지 않는다.
	3) 생성자 사용 시 매개변수의 타입 / 개수가 일치하게 사용	
- 종류
	1) 디폴트 생성자 : 생성자를 선언하지 않은 클래스에 컴파일에서 자동으로 만들어주는 생성자 
		-> 생성자명(){};
	2) 사용자 지정 생성자 : main 함수에서 클래스를 사용할 객체를 생성할 때 인수값을 지정해 해당 클래스의 생성자에게 매개변수로 전달
		-> 생성자명(매개변수){ 실행 코드 };
		- 관례적으로 클래스의 멤버변수명과 생성자의 매개변수명과 동일하게 코드 작성 -> 컴파일러가 식별 불가 -> this 키워드 사용
- 오버로드 : 동일한 생성자명을 여러 개 선언하는 것 -> 매개변수의 개수 / 타입 / 순서가 다를 경우에만 가능(매개변수명으로는 식별 불가)
- 주의점 
	1) 멤버변수가 많으면 과도한 생성자의 개수가 경우에 따라 늘어갈 수 있따 -> 관리 / 유지보수가 힘들어짐

----------------------------------------------------------------------------------------------------

[배열]
- 동일한 자료형의 서로 다른 값을 한번에 관리하는 자료구조 -> 기본자료형 8가지 + 클래스
- 배열 선언 
	- 형식 : 자료형[] 배열변수명 = new 자료형[길이];
	---> 자료형 : 배열에 저장할 자료들의 공통 자료형
	---> new : 객체 / 배열을 생성하기 위한 키워드
	---> 길이 : 배열에 저장할 자료의 최대 개수 (주의점 . 고정길이로 선언된 이후 배열 길이 변경 불가)
- 배열의 초기화 ★ 초기값을 지정하지 않을 시 기본값 지정 -> 초기값으로 설정할 값이 배열의 기본값과 같다면 지정하지 않아도 됨
				-> 기본값 : 정수(0) / 실수(0.0) / 객체(null) / 논리(false)
	- 형식
		1) 자료형[] 배열변수명 = new 자료형[] { 값1 , 값2 , 값3 }
		2) 자료형[] 배열변수명 = { 값1 , 값2 , 값3 }
		3) 자료형[] 배열변수명; 배열변수명 = new 자료형[] { 값1 , 값2 , 값3 };
- 배열 호출
	- 형식 : 배열변수명[index] = 값;
- 배열 길이 속성 : 배열변수명.length;
	-> 배열과 반복문의 관계 : 배열은 인덱스가 0부터 1씩 증가 하는 규칙이 존재한다.
	- for(자료형 변수명 ; 변수명1 <= 배열명.length -1; 변수명1++){
	  	자료형 변수명2 = 배열명[변수명1]
	  }

----------------------------------------------------------------------------------------------------

[이스케이프 / 제어문자]
1. \n : 줄바꿈
2. \t : 공백
3. \" : 큰 따옴표 한 개 출력
4. \' : 작은 따옴표 한 개 출력
5. \\ : 백 슬래시 한 개 출력
-> JAVA/ 파이썬 / C 모두 동일


[패키지]
- 전체 소스코드를 구성하는 계층 구조를 지원
- 식별자 역할을 하여 서로 다른 패키지에서는 동일한 이름을 가진 클래스를 생성할 수 있음
	-> 주의점 . 자동 완성 시 같은 이름을 가진 클래스가 어디 패키지에 들어있는 클래스인지 확인하고 사용하기
- 패키지를 잘 관리할 시 코드 관리 / 유지보수가 편해짐


[자바 이름 짓기 규약]
- 패키지 / 폴더명 : 모두 소문자
- 클래스명 : 첫글자 대문자
- 변수 / 함수명 : 첫글자 소문자, 중간에 새단어의 첫글자 대문자 => 카멜표기법 사용
★ 객체명 / 배열명은 존재하지 않는다. => 변수에 객체 / 배열을 넣어서 상징적인 이름을 부여 





======================================================================

*** 용어 정리 ***

1. 객체(Object) 
	- 객체 지향 프로그램의 대상 -> 생성된 인스턴스
	- 물리적 / 논리적(추상적) 개념을 가진 대상 / 물체
	- 주체를 제외하고 고유한 성질 / 행위 를 가진 대상
2. 클래스(class)
	- 객체를 프로그래밍하기 위해 코드로 만든 상태
	- 대상 / 물체 를 분류
	- 사용자 지정 자료형
	- 객체를 만들기 위한 설계도
3. 인스턴스(instance) 
	- 클래스가 메모리에 생성된 상태 -> new 연산자로 만들어진 객체(객체이자 인스턴스)
	- 대상 / 물체를 발의 -> 값을 실질적으로 지정한
4. 멤버변수 
	- 클래스의 속성 / 특성
	- 특정한 곳에 구성된 변수 -> 특정 클래스 내에 구성된
	- 객체(인스턴스) 내 할당된 변수
5. 메소드 
	- 멤버 변수를 이용하여 클래스의 기능 구현
	- 특정한 곳에 구성된 함수 -> 특정 클래스 내에 구성된
	- 객체(인스턴스)가 사용하는 함수
6. 참조(reference)변수 
	- 메모리에 생성된 인스턴스를 가리키는 변수
	- 객체(인스턴스)의 주소를 갖는 변수
7. 참조(reference)값 
	- 생성된 인스턴스의 메모리 주소값
	- 객체(인스턴스)의 주소
		
======================================================================












    